exit
(num.inject(0) { |sum, num_slices| sum + num_slices } / self.all.size.to_f ).round(2)
num.inject(0) { |sum, num_slices| sum + num_slices } / self.all.size.to_f ).round(2)
num
num = self.all.map{|order| order.slices.count}
self.all.map{|order| order.slices.count}[B
self.all.map{|order| order.slices.inject(0){|sum, order| order.slices.count}}
self.all.map{|order| order.slices.inject(0){|sum, order| order.slices.count}
self.all
self.all.map do |order|
    end
      order.slices.inject(0) { |sum, order| sum + order.slices.count }
self.all.map do |order|
self.all
self.total_slices_per_order
exit
users.pluck('users.id')
users.pluck(:id)
users
exit
u.count
u
u = users.limit(5)
users.limit(5)
users.count
users
exitusers
exit
users.to_a
users.count
u = users.limit(5)
users
users.limit(5)
users.count
users
exit
users.count
users.all
users
exit
users.count
users.first
users
users.pluck(:name)
users.pluck(:name(
users
exit
us.each{|i| puts i}
us
us = User.select("users.name, count(users.events.id) AS events_count").group(:name)
us.each{|i| puts i}
us.pluck(:events_count)
us = User.select("users.name, count(events.id) AS events_count").group(:name)
us.pluck(:events)
us.pluck(:name)
us.each{|i| puts i.name}
us
us = User.select("users.name, count(events.id)").group(:name)
users = _
User.select("users.name, count(events.id)").group(:name)
User.select(:name, count(slices.id))
User.select(:name, count(users.slices.id))
users.first
users = User.select( "users.*, count(events.id) AS events_count" ).joins(:events).group('users.id')
users = User.select( "users.*, count(events.id) AS events_count" ).joins(:events)
User.all.pluck(:name, :id)
User.all.pluck(:name, :password)
User.all
User.select('users.name, users.password')
User.select("users.name, count('events.id')").group(:id)
User.select("users.name, count('users.events.id')").group(:id)
users.pluck("count('users.events.id')").group('users.id')
users.pluck("count('users.events.id')")
users.pluck("count('users.events.id'))
users.pluck("count('users.events.id')))
users.pluck(:name)
User.select("users.name, count('users.events.id')")
User.select(:name, count('events.id'))
User.joins(:events).select(:name, count('events.id'))
User.joins(:events).select(:name, count(events.id))
User.select(:name, count(events.id))
User.select(:name)
Users.select(:name)
users.pluck(:name, :events_count)
users.pluck(:name)
u.name
u = _
users.limit(1)
users
users.first
users
exit
users.pluck(:id)
users.length
users.count
users
exitusers
exit
users.first
users.pluck(:name, :event_count)
users
query
exit
q
exit
self.orders
self
pie_types_hash
exit
pie_types_hash
continue
exit
expect(event.restaurant).to eq(restaurant)
event.restaurant = restaurant
event.restaurant
event
exit
event.restaurant.pizzas.map {|za| za.topping}
event.restaurant.pizzas.all
event.restaurant.pizzas
event.restaurant
event
continue
@event = Event.new(event_params)
event_params
self
date
Event.where(date: Time.now.day) 
Event.where(date: #{Time.now.day}) 
Event.where(date: #{Time.now.day}") 
Event.where(date.day: #{Time.now.day}") 
Event.where("events.date = Time.now.day")
Event.where("events.date == Time.now.")
Event.where("event.date == Time.now.day")
Event.where("events.date == Time.now.day")
Event.where("events.date.day == Time.now.day")
Event.where("events.date.month == #{Time.now.month}")
Event.where("events.date.month == #{Time.now.month})
Event.where
events.where
self.all
Self.all
exit
Event.all.count
@events.count
@events
exit
selfexit
self.all
self
Event.connection
self
exit
<<<<<<< HEAD
page.body
exit
page.content
page
exit
User.all
Event.all
exit
<<<<<<< HEAD
=======
>>>>>>> 728b183dfa29fa5f9868043c807a9df272674a27
Time.now >= self.deadline && Time.now < self.date
Time.now < self.deadline
Time.now > self.deadline
end
if Time.now > self.deadline
(Time.now..self.date) == Time.now
(self.deadline..self.date) == Time.now
(self.deadline..self.date).include?(Time.now)
(self.deadline..self.date) == Time.now
(self.deadline..self.date)
self.deadline
exit
@event.orders.map {|order| order.user.name}
@event.orders.map {|order| order.user.name]
@event.orders
@event
exit
@event
params
exit
params
exit
<<<<<<< HEAD
order.event.date.time.current
order.event.date.time
order.event.date.date
order.event.date.time
order.event.date
order.user.email
order.email
order.slices.count
order.slicesc.count
order.slices
order.event.title
order.title
order.user.email
order.user
self.orders.count
self.orders
self
order
self
self.pizza
self.slices
self.orders
self
exit
=======
<<<<<<< HEAD
=======
<<<<<<< HEAD
total
exit
continue
item_type
continue
exit
total
continue
total
continue
total
continue
total
exit
total
continue
total_slices_price(item_hash, total)
item_hash
item_type
total
continue
total_pies_price(item_hash, total)
total
total_pies_price(item_hash)
item_hash
item_type
exit
total
item_type
continue
total
item_type
continue
total
continue
total
exit
Pizza.last
Pizza.all
Pizza.find_by_topping("cheese").price
